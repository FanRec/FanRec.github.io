**拓扑排序（Topological sorting）**要解决的问题是如何给一个有向无环图的所有节点排序。

我们可以说 在一个 [DAG（有向无环图）](https://oi-wiki.org/graph/dag/) 中，我们将图中的顶点以线性方式进行排序，使得对于任何的顶点 𝑢![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 到 𝑣![v](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的有向边 (𝑢,𝑣)![(u,v)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7), 都可以有 𝑢![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 在 𝑣![v](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的前面。

给定一个 DAG，如果从 𝑖![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 到 𝑗![j](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 有边，则认为 𝑗![j](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 依赖于 𝑖![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。如果 𝑖![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 到 𝑗![j](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 有路径（𝑖![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 可达 𝑗![j](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)），则称 𝑗![j](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 间接依赖于 𝑖![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)。

拓扑排序的目标是将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。



```c
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

//n 顶点数
//G 邻接表
//inDegree 入度数组
bool TopSort(int n,vector<vector<int>> &G,vector<int>& inDegree){
    queue<int> q;vector<int> result;

    for(int i = 0;i < n;i++){
        if(inDegree[i]==0)q.push(i);
    }

    while(!q.empty()){
        int u = q.front();
        q.pop();
        result.push_back(u);

        for(int v : G[u]){
            if(--inDegree[v]==0)q.push(v);
        }
    }

    if(result.size()==n){
        for(int i = 0;i < n;i++)cout << result[i]<<(i == n-1?"":" ");
        return true;
    }else{
        return false;
    }
}
int main(){
    int n,m;
    cin>>n>>m;
    
}
```

