[P3366 【模板】最小生成树 - 洛谷](https://www.luogu.com.cn/problem/P3366)

# P3366 【模板】最小生成树

## 题目描述

如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。

## 输入格式

第一行包含两个整数 $N,M$，表示该图共有 $N$ 个结点和 $M$ 条无向边。

接下来 $M$ 行每行包含三个整数 $X_i,Y_i,Z_i$，表示有一条长度为 $Z_i$ 的无向边连接结点 $X_i,Y_i$。

## 输出格式

如果该图连通，则输出一个整数表示最小生成树的各边的长度之和。如果该图不连通则输出 `orz`。

## 输入输出样例 #1

### 输入 #1

```
4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3
```

### 输出 #1

```
7
```

## 说明/提示

数据规模：

对于 $20\%$ 的数据，$N\le 5$，$M\le 20$。

对于 $40\%$ 的数据，$N\le 50$，$M\le 2500$。

对于 $70\%$ 的数据，$N\le 500$，$M\le 10^4$。

对于 $100\%$ 的数据：$1\le N\le 5000$，$1\le M\le 2\times 10^5$，$1\le Z_i \le 10^4$，$1\le X_i,Y_i\le N$。


样例解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2259.png) 

所以最小生成树的总边权为 $2+2+3=7$。
### Prim算法解

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 99999999
int n,m;
struct EdgeNode{
    int v;
    int w;
    bool operator <(const EdgeNode& a) const{
        return w >= a.w;
    }
};
vector<vector<EdgeNode>> edges;
vector<int> dist,vis;
int Prim(){
    int ans = 0;
    priority_queue<EdgeNode> pq;
    dist.resize(n+1,inf);
    vis.resize(n+1,0);
    dist[1] = 0;
    pq.push({1,0});
    while(!pq.empty()){
        int u = pq.top().v,w = pq.top().w;
        pq.pop();
        if(vis[u])continue;
        vis[u] = 1;
        ans += w;
        for(auto nxt : edges[u]){
            int v = nxt.v,w = nxt.w;
            if(w < dist[v]){
                dist[v] = w;
                pq.push({v,dist[v]});
            }
        }
    }
    return ans;
}
void solve(){
    cin>>n>>m;
    edges.resize(n+1);
    for(int i = 0;i < m;++i){
        int u,v,w;
        cin>>u>>v>>w;
        edges[u].push_back({v,w});
        edges[v].push_back({u,w});
    }
    int ans = Prim();
    int flag = 1;
    for(int i = 1;i<=n;i++){
        if(!vis[i]){
            flag = 0;
            break;
        }
    }
    if(flag){
        cout<<ans;
    }else cout<<"orz";
}
int main(){
    solve();
}
```

### Kruskal算法解

```cpp
#include<bits/stdc++.h>
using namespace std;
#define inf 99999999
int n,m;
struct EdgeNode{
    int u;
    int v;
    int w;
    bool operator <(const EdgeNode& a) const{
        return w < a.w;
    }
};
int total = 1;
vector<int>fa;
vector<EdgeNode> edges;
vector<int> dist,vis;
#pragma region 并查集
int find(int x){
    if(x!=fa[x]) fa[x] = find(fa[x]);
    return fa[x];
}
// void merge(int x,int y){
//     int fx = find(x),fy = find(y);
//     if(fx!=fy) fa[fx] = fy;
// }
#pragma endregion
#pragma region Kruskal
int kruskal(){
    int ans = 0;
    fa.resize(n+1);
    for(int i = 1;i<=n;++i){
        fa[i] = i;
    }
    for(int i = 0;i < m;++i){
        int u,v,w;
        cin>>u>>v>>w;
        edges.push_back({u,v,w});
    }
    sort(edges.begin(),edges.end());
    for(auto [u,v,w] : edges){
        u = find(u); v = find(v);
        if(u!=v){
            fa[u] = v;
            ans += w;
            total++;
        }
    }
    return ans;
}
#pragma endregion
void solve(){
    cin>>n>>m;
    int ans = kruskal();
    if(total==n){
        cout<<ans;
    }else cout<<"orz";
}
int main(){
    solve();
}
```

## 其他题目

[P1396 营救 - 洛谷](https://www.luogu.com.cn/problem/P1396)
[P1967 [NOIP 2013 提高组\] 货车运输 - 洛谷](https://www.luogu.com.cn/problem/P1967)