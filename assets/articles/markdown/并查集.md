并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

### **初始化**

```c
void init(){
    for(int i = 0;i < MAXN;++i){
        pre[i] = i;
        rank[i] = 0;
    }
}
```

### **并查集操作**

并查集支持两种操作

- 合并（Unite）：合并两个元素所属集合（合并对应的树）。
- 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合。

```c
#include <stdio.h>
#define MAXN 10000
int pre[MAXN];

//没有任何优化
int find(int x){
    while(x!=pre[x])x = pre[x];
    return x;
}
void join( int x, int y){
    int fx = find(x),fy=find(y);
    if(fx!=fy)pre[fx] = fy;
}

```

### **路径压缩优化**

在查找的时候递归的把自己的前驱设置为根

```c
//路径压缩
int find(int x){
    if(pre[x]==x)return x;
    return pre[x] = find(pre[x]);
}
```

**按秩合并优化**

防止合并后的树退化（使树中左右子树的深度差尽可能小）

```c
#include <stdio.h>
#define MAXN 10000
int pre[MAXN];
int rank[MAXN];
//按秩合并优化
void join(int x, int y){
    x = find(x),y=find(y);
    if(x==y)return;
    if(rank[x]>rank[y])pre[y]=x;
    else{
        if(rank[x]==rank[y])rank[y]++;
        pre[x] = y;
    }
}

```

# P1551 亲戚

## 题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

## 题目描述

规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。

## 输入格式

第一行：三个整数 $n,m,p$，（$n,m,p \le 5000$），分别表示有 $n$ 个人，$m$ 个亲戚关系，询问 $p$ 对亲戚关系。

以下 $m$ 行：每行两个数 $M_i$，$M_j$，$1 \le M_i,~M_j\le n$，表示 $M_i$ 和 $M_j$ 具有亲戚关系。

接下来 $p$ 行：每行两个数 $P_i,P_j$，询问 $P_i$ 和 $P_j$ 是否具有亲戚关系。

## 输出格式

$p$ 行，每行一个 `Yes` 或 `No`。表示第 $i$ 个询问的答案为“具有”或“不具有”亲戚关系。

## 输入输出样例 #1

### 输入 #1

```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6
```

### 输出 #1

```
Yes
Yes
No
```


我的解(C++)

```c++
#include <bits/stdc++.h>
#define MAXN 10000
using namespace std;

int pre[MAXN];
int n,m,p;

void init(){
    for(int i = 1;i <= n;++i){
        pre[i] = i;
    }
}

int find(int x){
    if(pre[x]==x)return x;
    return pre[x] = find(pre[x]);
}
void join(int x, int y){
    x = find(x),y=find(y);
    if(x!=y)pre[x] = y;
}
void isConnected(int x, int y){
    if(find(x)==find(y))printf("Yes\n");
    else printf("No\n");
}

int main(){
    cin>>n>>m>>p;
    init();
    int a,b;
    while(m--){
        cin>>a>>b;
        join(a,b);
    }
    while(p--){
        cin>>a>>b;
        isConnected(a,b);
    }
}
```

