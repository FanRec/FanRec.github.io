并查集是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。

顾名思义，并查集支持两种操作：

- 合并（Unite）：合并两个元素所属集合（合并对应的树）。
- 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合。

**初始化**

```c
void init(){
    for(int i = 0;i < MAXN;++i){
        pre[i] = i;
        rank[i] = 0;
    }
}
```

**并查集操作**

```c
#include <stdio.h>
#define MAXN 10000
int pre[MAXN];

//没有任何优化
int find(int x){
    while(x!=pre[x])x = pre[x];
    return x;
}
void join( int x, int y){
    int fx = find(x),fy=find(y);
    if(fx!=fy)pre[fx] = fy;
}

```

find**路径压缩优化**

```c
#include <stdio.h>
#define MAXN 10000
int pre[MAXN];

//路径压缩
int find(int x){
    if(pre[x]==x)return x;
    return pre[x] = find(pre[x]);
}
void join( int x, int y){
    x = find(x),y=find(y);
    if(x!=y)pre[x] = y;
}

```

**按秩合并优化**

```c
#include <stdio.h>
#define MAXN 10000
int pre[MAXN];
int rank[MAXN];

int find(int x){
    if(pre[x]==x)return x;
    return pre[x] = find(pre[x]);
}
void join(int x, int y){
    x = find(x),y=find(y);
    if(x==y)return;
    if(rank[x]>rank[y])pre[y]=x;
    else{
        if(rank[x]==rank[y])rank[y]++;
        pre[x] = y;
    }
}

```

